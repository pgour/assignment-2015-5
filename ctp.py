import sys, getoptfrom sets import Setfrom heapq import heappush, heappopclass node:#Ayth einai h klash pou anaparasta ton komvo enos grafhmatos    label = ''    neighbors = []     distances = []     prevNode = None     totalDistance = float('Inf')    visited = False     def __init__(self, label): # constructor        self.label = label        self.neighbors = []        self.distances = []        self.prevNode = None        self.totalDistance = float('Inf')        self.visited = Falsedef makeGraph(file): #Auth h sinarthsh pairnei ws eisodo ena arxeio pou anaparasta ena grafhma kai kataskeuazei tis listes geitniashs toy grafou.	existingNodes = Set()	graph = []	for line in file:		#print line		numbers = line.split( ' ' ) 		#print numbers		node1 = numbers[ 0 ] 		if not (node1 in existingNodes): 			x = node( node1 )			graph.append( x ) 			existingNodes.add( node1 )		else:			for n in graph: 				if( n.label == node1 ):					x = n					break;		node2 = numbers[ 1 ] 		if not (node2 in existingNodes):			y = node( node2 )			graph.append( y ) 			existingNodes.add( node2 )		else:			for n in graph: 				if( n.label == node2 ):					y = n					break;		weight = float( numbers[ 2 ].replace( "\r\n","" ) )		x.neighbors.append( y )		x.distances.append( weight )		y.neighbors.append( x )		y.distances.append( weight )	file.close()	return graphdef getBlockedEdges(file): #Auth h sinarthsh apothikeuei tis blocked akmes enos grafimatos	blockedEdges = []	for line in file:		#print line		numbers = line.split( ' ' )		#print numbers		node1 = numbers[ 0 ].replace( "\r\n","" )		node2 = numbers[ 1 ].replace( "\r\n","" )		blockedEdges.insert( 0, ( node1, node2 ) )	file.close()	return blockedEdgesdef removeEdge(graph, blockedEdge): #Auth h sinarthsh diagrafei mia akmh apo to grafhma (tous komvos ths akmhs kai tis apostaseis tous)	for n in graph:		if n.label == blockedEdge[0] or n.label == blockedEdge[1]:			for i in range(len(n.neighbors)):				if n.neighbors[i].label == blockedEdge[0] or n.neighbors[i].label == blockedEdge[1]:					n.neighbors.remove( n.neighbors[i] )					break	return graphdef getDistance(graph, label1, label2): #Auth h sinarthsh pairnei ws eisodo ta labels 2 komvwn kai epistrefei thn apostash stous	for n in graph:		if n.label == label1 or n.label == label2:			for i in range(len(n.neighbors)):				if n.neighbors[i].label == label1 or n.neighbors[i].label == label2:					return n.distances[i]	return 0def searchNodeInGraph(label): #Auth h sinarthsh psaxnei enan komvo sto grafima me vash to label enos komvou	for n in graph:		if( n.label == label ):			return n	return -1def printGraph(graph): #Auth h sinarthsh tipwnei tis listes geitniashs enos komvou	print ("\nThe graph:")	for n in graph:		print ('Node: ', n.label)		print ('Neighbors:')		for i in range(len(n.neighbors)):			print (n.neighbors[i].label, n.distances[i])		printdef repositioning_dijkstra(startNode, pq, graph, node, blockedEdges, endNode):#Auth h sinarthsh ylopoihsh ton zitoumeno repositioning algorithm	#print 'Current node ', node.label	currentNode = node	for i in range(len(node.neighbors)):		n = node.neighbors[i]		#print '\nCheck edge ', node.label, n.label		if (node.label, n.label) in blockedEdges or (n.label, node.label) in blockedEdges:			#print '\n\tBlocked edge ', node.label, n.label			removeEdge(graph, (node.label, n.label))			returnInTheBeginning( startNode, node )			return (len(pq), node)		d = node.distances[i]		#print 'n.totalDistance = ', n.totalDistance		#print 'd = ', d		#print 'node.totalDistance = ', node.totalDistance		#print 'n.totalDistance > d + node.totalDistance = ', n.totalDistance > d + node.totalDistance		if n.totalDistance > d + node.totalDistance:			n.prevNode = node			n.totalDistance = d + node.totalDistance			#print '\nInserted node to the heap ', n.label			heappush(pq, (n.totalDistance, n))		node.visited = True	if len(pq) > 0:		(d, ne) = heappop(pq)		if not ne.visited:			length, tmpNode = repositioning_dijkstra(startNode, pq, graph, ne, blockedEdges, endNode)#Kaleitai anadromika h sinarthsh gia ton epomenh komvo pou exei eisaxthei sto swro			if not (tmpNode.label != currentNode.label and currentNode.label == endNode.label):				currentNode = tmpNode	return (len(pq), currentNode)def dijkstra(pq, node):#Auth h sinarthsh einai o klassikos algorithmos tou Dijkstra (epi ths ousias einai o prohgoumenos algorithmos xwris to repositioning	for i in range(len(node.neighbors)):		n = node.neighbors[i]		d = node.distances[i]		if n.totalDistance > d + node.totalDistance:			n.prevNode = node			n.totalDistance = d + node.totalDistance			heappush(pq, (n.totalDistance, n))	node.visited = True	if pq:		(d, ne) = heappop(pq)		if not ne.visited:			dijkstra(pq, ne)def route(endNode):#Auth h sinarthsh tipwnei ena monopati komvwn    node = endNode    labels = [endNode.label]    while node.label != node.prevNode.label:        node = node.prevNode        labels.append(node.label)    labels.reverse()    return labelsdef returnInTheBeginning(startNode, node):#Auth h sinarthsh diasxizei ena monopati mexri ton startNode	prevNode = node	while node.label != startNode.label:		#print 'returnInTheBeginning ', node.label, ' node.prevNode = ', node.prevNode.label		#node.prevNode.prevNode = node		node.prevNode.totalDistance = getDistance(graph, node.label, node.prevNode.label) + node.totalDistance		prevNode = node		node = node.prevNode	node.totalDistance = getDistance(graph, node.label, prevNode.label) + prevNode.totalDistancedef greedy_dijkstra(pq, graph, node, blockedEdges):#Auth h sinarthsh einai h greedy version toy Dijkstra	#print 'Current node ', node.label	if node.label != endNode.label:		for i in range(len(node.neighbors)):			node.visited = True			n = node.neighbors[i]			#print '\nCheck edge ', node.label, n.label			if (node.label, n.label) in blockedEdges or (n.label, node.label) in blockedEdges:				#print '\n\tBlocked edge ', node.label, n.label				continue			d = node.distances[i]			#print 'n.totalDistance = ', n.totalDistance			#print 'd = ', d			#print 'node.totalDistance = ', node.totalDistance			#print 'n.totalDistance > d + node.totalDistance = ', n.totalDistance > d + node.totalDistance			if n.totalDistance > d + node.totalDistance:				n.prevNode = node				n.totalDistance = d + node.totalDistance				#print '\nInserted node to the heap ', n.label				heappush(pq, (n.totalDistance, n))	if len(pq) > 0:		(d, ne) = heappop(pq)		if not ne.visited:			greedy_dijkstra(pq, graph, ne, blockedEdges)def repositioning_route(startNode, endNode):#Auth h sinarthsh epistrefei ena path gia ton repositioning algorithmo	node = endNode	if node.label == startNode.label:		labels = []	else:		labels = [endNode.label]	while node.label != startNode.label and node.label != node.prevNode.label:		node = node.prevNode		labels.append(node.label)	labels.reverse()	return labelsdef greedy_route(startNode, endNode):#Auth h sinarthsh epistrefei ena path gia ton greedy algorithmo	node = endNode	labels = [endNode.label]	while node.label != startNode.label and node.label != node.prevNode.label:		node = node.prevNode		labels.append(node.label)	labels.reverse()	return labelsdef backwardRoute(startNode, labels, endNode):#Auth h sinarthsh epistrefei ena path anapoda	node = endNode	while node.label != node.prevNode.label and node.label != startNode.label:		if node.label != endNode.label:			labels.append(node.label)		node = node.prevNode	return labelsdef reset(graph):#Auth h sinarthsh kanei reset to flag 'visited' kai th metavlith totalDistance apeiro.	for n in graph:		n.visited = False		n.totalDistance = float('Inf')	return graphif len(sys.argv) < 4:	print '\nctp.py usage: ctp.py graph_file start_node destination_node [-r] [-b blocked_edges_file]'else:	file = open( sys.argv[ 1 ], 'r' ) #H parametros 'graph_file' apo thn grammh entolwn	graph = makeGraph( file )	#printGraph(graph)	startNode = searchNodeInGraph( sys.argv[ 2 ] )	if startNode != -1:		startNode.prevNode = startNode		startNode.totalDistance = 0		endNode = searchNodeInGraph( sys.argv[ 3 ] ) 		if endNode != -1:			if len(sys.argv) == 4:				dijkstra( [], startNode )				labels = route( endNode )				print( labels )				print( endNode.totalDistance )			if len(sys.argv) == 5:				if sys.argv[ 4 ] == '-r':					dijkstra( [], startNode )					labels = route( endNode )					print( labels )					print( endNode.totalDistance )				else:					print '\nctp.py usage: ctp.py graph_file start_node destination_node [-r] [-b blocked_edges_file]'			if len(sys.argv) == 6:				if sys.argv[ 4 ] == '-b':					file2 = open( sys.argv[ 5 ], 'r' )					blockedEdges = getBlockedEdges(file2)					greedy_dijkstra([], graph, startNode, blockedEdges)					labels = greedy_route( startNode, endNode )					print( labels )					print( endNode.totalDistance )				else:					print '\nctp.py usage: ctp.py graph_file start_node destination_node [-r] [-b blocked_edges_file]'			if len(sys.argv) == 7:				if sys.argv[ 4 ] == '-r' and sys.argv[ 5 ] == '-b':					file2 = open( sys.argv[ 6 ], 'r' )					blockedEdges = getBlockedEdges( file2 )					labels = []					totalDistance = 0					length, node = repositioning_dijkstra(startNode, [], graph, startNode, blockedEdges, endNode)					while( node.label != endNode.label ):						currentLabels = repositioning_route( startNode, node )						#print 'currentLabels1 = ', currentLabels						currentLabels = backwardRoute( startNode, currentLabels, node )						#print 'currentLabels2 = ', currentLabels						for i in range(len(currentLabels)):							labels.append( currentLabels[i] )						totalDistance = totalDistance + startNode.totalDistance						#print( labels )						#print( totalDistance )						graph = reset(graph)						startNode.prevNode = startNode						startNode.totalDistance = 0						length, node = repositioning_dijkstra(startNode, [], graph, startNode, blockedEdges, endNode)						#print 'length = ', length					currentLabels = repositioning_route( startNode, node )					for i in range(len(currentLabels)):						labels.append( currentLabels[i] )					totalDistance = totalDistance + endNode.totalDistance					print( labels )					print( totalDistance )				else:					print '\nctp.py usage: ctp.py graph_file start_node destination_node [-r] [-b blocked_edges_file]'		else:			print '\n\nUnknown destination node.'	else:		print '\n\nUnknown start node.'